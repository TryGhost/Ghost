diff --git a/node_modules/i18next-cli/dist/esm/extractor/core/extractor.js b/node_modules/i18next-cli/dist/esm/extractor/core/extractor.js
old mode 100644
new mode 100644
--- a/node_modules/i18next-cli/dist/esm/extractor/core/extractor.js
+++ b/node_modules/i18next-cli/dist/esm/extractor/core/extractor.js
@@ -1,1 +1,1 @@
-import t from"ora";import a from"chalk";import{parse as e}from"@swc/core";import{mkdir as o,writeFile as r,readFile as n}from"node:fs/promises";import{dirname as s,extname as i}from"node:path";import{findKeys as c}from"./key-finder.js";import{getTranslations as l}from"./translation-manager.js";import{validateExtractorConfig as m,ExtractorError as p}from"../../utils/validation.js";import{extractKeysFromComments as f}from"../parsers/comment-parser.js";import{ConsoleLogger as u}from"../../utils/logger.js";import{loadRawJson5Content as y,serializeTranslationFile as d}from"../../utils/file-utils.js";import{shouldShowFunnel as g,recordFunnelShown as w}from"../../utils/funnel-msg-tracker.js";async function h(e,{isWatchMode:n=!1,isDryRun:i=!1,syncPrimaryWithDefaults:p=!1,syncAll:f=!1}={},h=new u){e.extract.primaryLanguage||=e.locales[0]||"en",e.extract.secondaryLanguages||=e.locales.filter(t=>t!==e?.extract?.primaryLanguage),e.extract.functions||=["t","*.t"],e.extract.transComponents||=["Trans"],m(e);const x=e.plugins||[],j=t("Running i18next key extractor...\n").start();try{const{allKeys:t,objectKeys:n}=await c(e,h);j.text=`Found ${t.size} unique keys. Updating translation files...`;const m=await l(t,n,e,{syncPrimaryWithDefaults:p,syncAll:f});let u=!1;for(const t of m)if(t.updated&&(u=!0,!i)){const n=e.extract.outputFormat??(t.path.endsWith(".json5")?"json5":"json"),i="json5"===n?await y(t.path)??void 0:void 0,c=d(t.newTranslations,n,e.extract.indentation,i);await o(s(t.path),{recursive:!0}),await r(t.path,c),h.info(a.green(`Updated: ${t.path}`))}if(x.length>0){j.text="Running post-extraction plugins...";for(const t of x)await(t.afterSync?.(m,e))}return j.succeed(a.bold("Extraction complete!")),u&&await async function(){if(!await g("extract"))return;return console.log(a.yellow.bold("\nðŸ’¡ Tip: Tired of running the extractor manually?")),console.log('   Discover a real-time "push" workflow with `saveMissing` and Locize AI,'),console.log("   where keys are created and translated automatically as you code."),console.log(`   Learn more: ${a.cyan("https://www.locize.com/blog/i18next-savemissing-ai-automation")}`),console.log(`   Watch the video: ${a.cyan("https://youtu.be/joPsZghT3wM")}`),w("extract")}(),u}catch(t){throw j.fail(a.red("Extraction failed.")),t}}async function x(t,a,o,r,s,c=new u){try{let l=await n(t,"utf-8");for(const e of a)try{const a=await(e.onLoad?.(l,t));void 0!==a&&(l=a)}catch(t){c.warn(`Plugin ${e.name} onLoad failed:`,t)}const m=i(t).toLowerCase(),u=".ts"===m||".tsx"===m||".mts"===m||".cts"===m,y=".tsx"===m,d=".jsx"===m;let g;try{g=await e(l,{syntax:u?"typescript":"ecmascript",tsx:y,jsx:d,decorators:!0,dynamicImport:!0,comments:!0})}catch(a){if(".ts"!==m||y)throw new p("Failed to process file",t,a);try{g=await e(l,{syntax:"typescript",tsx:!0,decorators:!0,dynamicImport:!0,comments:!0}),c.info?.(`Parsed ${t} using TSX fallback`)}catch(a){throw new p("Failed to process file",t,a)}}r.getVarFromScope=o.getVarFromScope.bind(o),o.setCurrentFile(t,l),o.visit(g),f(l,r,s,o.getVarFromScope.bind(o))}catch(a){throw new p("Failed to process file",t,a)}}async function j(t,{syncPrimaryWithDefaults:a=!1}={}){t.extract.primaryLanguage||=t.locales[0]||"en",t.extract.secondaryLanguages||=t.locales.filter(a=>a!==t?.extract?.primaryLanguage),t.extract.functions||=["t","*.t"],t.extract.transComponents||=["Trans"];const{allKeys:e,objectKeys:o}=await c(t);return l(e,o,t,{syncPrimaryWithDefaults:a})}export{j as extract,x as processFile,h as runExtractor};
+import t from"ora";import a from"chalk";import{parse as e}from"@swc/core";import{mkdir as o,writeFile as r,readFile as n}from"node:fs/promises";import{dirname as s,extname as i}from"node:path";import{findKeys as c}from"./key-finder.js";import{getTranslations as l}from"./translation-manager.js";import{validateExtractorConfig as m,ExtractorError as p}from"../../utils/validation.js";import{extractKeysFromComments as f}from"../parsers/comment-parser.js";import{ConsoleLogger as u}from"../../utils/logger.js";import{loadRawJson5Content as y,serializeTranslationFile as d}from"../../utils/file-utils.js";import{shouldShowFunnel as g,recordFunnelShown as w}from"../../utils/funnel-msg-tracker.js";async function h(e,{isWatchMode:n=!1,isDryRun:i=!1,syncPrimaryWithDefaults:p=!1,syncAll:f=!1}={},h=new u){e.extract.primaryLanguage||=e.locales[0]||"en",e.extract.secondaryLanguages||=e.locales.filter(t=>t!==e?.extract?.primaryLanguage),e.extract.functions||=["t","*.t"],e.extract.transComponents||=["Trans"],m(e);const x=e.plugins||[],j=t("Running i18next key extractor...\n").start();try{const{allKeys:t,objectKeys:n}=await c(e,h);j.text=`Found ${t.size} unique keys. Updating translation files...`;const m=await l(t,n,e,{syncPrimaryWithDefaults:p,syncAll:f});let u=!1;for(const t of m)if(t.updated&&(u=!0,!i)){const n=e.extract.outputFormat??(t.path.endsWith(".json5")?"json5":"json"),i="json5"===n?await y(t.path)??void 0:void 0,c=d(t.newTranslations,n,e.extract.indentation,i);await o(s(t.path),{recursive:!0}),await r(t.path,c),h.info(a.green(`Updated: ${t.path}`))}if(x.length>0){j.text="Running post-extraction plugins...";for(const t of x)await(t.afterSync?.(m,e))}return j.succeed(a.bold("Extraction complete!")),u&&await async function(){if(!await g("extract"))return;return console.log(a.yellow.bold("\nðŸ’¡ Tip: Tired of running the extractor manually?")),console.log('   Discover a real-time "push" workflow with `saveMissing` and Locize AI,'),console.log("   where keys are created and translated automatically as you code."),console.log(`   Learn more: ${a.cyan("https://www.locize.com/blog/i18next-savemissing-ai-automation")}`),console.log(`   Watch the video: ${a.cyan("https://youtu.be/joPsZghT3wM")}`),w("extract")}(),u}catch(t){throw j.fail(a.red("Extraction failed.")),t}}async function x(t,a,o,r,s,c=new u){try{let l=await n(t,"utf-8");for(const e of a)try{const a=await(e.onLoad?.(l,t));void 0!==a&&(l=a)}catch(t){c.warn(`Plugin ${e.name} onLoad failed:`,t)}const m=i(t).toLowerCase(),u=".ts"===m||".tsx"===m||".mts"===m||".cts"===m,y=".tsx"===m,d=".jsx"===m||".js"===m;let g;try{g=await e(l,{syntax:u?"typescript":"ecmascript",tsx:y,jsx:d,decorators:!0,dynamicImport:!0,comments:!0})}catch(a){if(".ts"!==m||y)throw new p("Failed to process file",t,a);try{g=await e(l,{syntax:"typescript",tsx:!0,decorators:!0,dynamicImport:!0,comments:!0}),c.info?.(`Parsed ${t} using TSX fallback`)}catch(a){throw new p("Failed to process file",t,a)}}r.getVarFromScope=o.getVarFromScope.bind(o),o.setCurrentFile(t,l),o.visit(g),f(l,r,s,o.getVarFromScope.bind(o))}catch(a){throw new p("Failed to process file",t,a)}}async function j(t,{syncPrimaryWithDefaults:a=!1}={}){t.extract.primaryLanguage||=t.locales[0]||"en",t.extract.secondaryLanguages||=t.locales.filter(a=>a!==t?.extract?.primaryLanguage),t.extract.functions||=["t","*.t"],t.extract.transComponents||=["Trans"];const{allKeys:e,objectKeys:o}=await c(t);return l(e,o,t,{syncPrimaryWithDefaults:a})}export{j as extract,x as processFile,h as runExtractor};
