#!/usr/bin/env tsx

import fs from 'fs/promises';
import path from 'path';
import { format } from 'prettier';
import { resolveRefs } from 'json-refs';
import jsonSchemaToZod from 'json-schema-to-zod';

/**
 * Base URL for Ghost SDK JSON Schema files
 */
const SCHEMA_BASE_URL = 'https://raw.githubusercontent.com/TryGhost/SDK/main/packages/admin-api-schema/lib/schemas';

/**
 * Resources to generate schemas for
 */
const RESOURCES = ['tags'] as const;
type Resource = typeof RESOURCES[number];

/**
 * Fetch a JSON Schema from the Ghost SDK repository
 */
async function fetchSchema(filename: string): Promise<Record<string, unknown>> {
    const url = `${SCHEMA_BASE_URL}/${filename}`;
    console.log(`  Fetching: ${filename}`);
    
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch ${filename}: ${response.statusText}`);
    }
    
    return response.json();
}

/**
 * Resolve $ref references in a JSON Schema
 */
async function resolveSchemaRefs(schema: Record<string, unknown>): Promise<Record<string, unknown>> {
    const result = await resolveRefs(schema, {
        location: SCHEMA_BASE_URL,
        loaderOptions: {
            processContent: (res: { text: () => Promise<string> }, callback: (err: Error | null, content?: unknown) => void) => {
                res.text()
                    .then((text) => callback(null, JSON.parse(text)))
                    .catch(callback);
            },
        },
    });
    
    return result.resolved as Record<string, unknown>;
}

/**
 * Convert resolved JSON Schema to Zod code
 */
function convertToZod(schema: Record<string, unknown>, name: string): string {
    try {
        return jsonSchemaToZod(schema, {
            name,
            module: 'esm',
        });
    } catch (error) {
        console.error(`Error converting ${name}:`, error);
        throw error;
    }
}

/**
 * Generate schema for a specific resource
 */
async function generateResourceSchema(resource: Resource): Promise<string> {
    console.log(`\nüìù Generating ${resource} schema...`);

    // Fetch the base schema (contains definitions)
    const baseSchema = await fetchSchema(`${resource}.json`);
    
    // Resolve all $ref references
    const resolvedBase = await resolveSchemaRefs(baseSchema);
    
    // Extract the main definition
    const definitions = (resolvedBase as any).definitions;
    const mainDef = definitions?.[resource.slice(0, -1)]; // 'tags' -> 'tag'
    
    if (!mainDef) {
        throw new Error(`No definition found for ${resource}`);
    }

    // Generate Zod schema from the resolved definition
    const baseZodCode = convertToZod(mainDef, `${capitalize(resource)}InputSchema`);

    // Build minimal generated file - ONLY contains the auto-generated schema
    // Note: json-schema-to-zod adds its own 'import { z } from "zod";' statement
    const schemaContent = `
// ============================================================================
// AUTO-GENERATED from Ghost SDK JSON Schemas
// Source: ${SCHEMA_BASE_URL}/${resource}.json
//
// DO NOT EDIT THIS FILE MANUALLY
// Run 'yarn generate' to regenerate from the official Ghost SDK schemas
//
// This file contains ONLY the pure JSON Schema ‚Üí Zod conversion
// All composed schemas and customizations are in ${resource}.ts
// ============================================================================

${baseZodCode}

// Export TypeScript type for the input schema
export type ${capitalize(resource.slice(0, -1))}Input = z.infer<typeof ${capitalize(resource)}InputSchema>;
`;

    // Format with Prettier
    const formatted = await format(schemaContent, {
        parser: 'typescript',
        singleQuote: true,
        tabWidth: 4,
        printWidth: 100,
    });

    return formatted;
}

/**
 * Capitalize first letter of a string
 */
function capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Main execution
 */
async function main() {
    console.log('üöÄ Generating Zod schemas from Ghost SDK JSON Schemas\n');

    try {
        // Generate schema for each resource
        for (const resource of RESOURCES) {
            const schema = await generateResourceSchema(resource);

            // Write to file
            const outputPath = path.join(process.cwd(), 'src', `${resource}.generated.ts`);
            await fs.writeFile(outputPath, schema, 'utf-8');

            console.log(`\n‚úÖ Generated: ${outputPath}`);
        }

        console.log('\nüéâ All schemas generated successfully!\n');
        console.log('üì¶ Next steps to add more resources:');
        console.log('   1. Add resource name to RESOURCES array (generate-schemas.ts)');
        console.log('   2. Run: yarn generate');
        console.log('   3. Create src/{resource}.ts to compose schemas (see tags.ts as example)');
        console.log('   4. Export from src/index.ts');
        console.log('\nüí° Remember:');
        console.log('   ‚Ä¢ *.generated.ts = AUTO-GENERATED (pure JSON Schema ‚Üí Zod)');
        console.log('   ‚Ä¢ *.ts = HAND-CRAFTED (composed schemas + custom logic)\n');
    } catch (error) {
        console.error('\n‚ùå Error generating schemas:', error);
        if (error instanceof Error) {
            console.error(error.stack);
        }
        process.exit(1);
    }
}

main();
