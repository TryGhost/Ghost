const sinon = require('sinon');
const assert = require('assert/strict');

const SingleUseTokenProvider = require('../../../../../core/server/services/members/SingleUseTokenProvider');

describe('SingleUseTokenProvider', function () {
    let tokenProvider;
    let mockMembersConfig;
    let mockModel;
    const testAuthSecret = Buffer.from('a'.repeat(128), 'hex'); // 64-byte secret

    beforeEach(function () {
        // Mock MembersConfigProvider
        mockMembersConfig = {
            getAuthSecret: sinon.stub().returns(testAuthSecret)
        };

        // Mock SingleUseTokenModel (minimal - we're not testing existing functionality)
        mockModel = {
            add: sinon.stub(),
            findOne: sinon.stub(),
            transaction: sinon.stub()
        };

        tokenProvider = new SingleUseTokenProvider({
            SingleUseTokenModel: mockModel,
            validityPeriod: 86400000, // 24 hours
            validityPeriodAfterUsage: 3600000, // 1 hour
            maxUsageCount: 3,
            secret: mockMembersConfig.getAuthSecret()
        });
    });

    afterEach(function () {
        sinon.restore();
    });

    describe('deriveOTC', function () {
        const testToken = {
            id: 'test-token-id',
            token: 'test-token-value'
        };

        it('should generate a 6-digit code', function () {
            const code = tokenProvider.deriveOTC(testToken.id, testToken.token);
            
            assert.equal(typeof code, 'string');
            assert.match(code, /^\d{6}$/);
        });

        it('should generate consistent codes for the same token', function () {
            const code1 = tokenProvider.deriveOTC(testToken.id, testToken.token);
            const code2 = tokenProvider.deriveOTC(testToken.id, testToken.token);
            
            assert.equal(code1, code2);
        });

        it('should generate different codes for different tokens', function () {
            const token1 = {id: 'token-1', token: 'value-1'};
            const token2 = {id: 'token-2', token: 'value-2'};
            
            const code1 = tokenProvider.deriveOTC(token1.id, token1.token);
            const code2 = tokenProvider.deriveOTC(token2.id, token2.token);
            
            assert.notEqual(code1, code2);
        });

        it('should generate different codes for same id with different token values', function () {
            const token1 = {id: 'same-id', token: 'value-1'};
            const token2 = {id: 'same-id', token: 'value-2'};
            
            const code1 = tokenProvider.deriveOTC(token1.id, token1.token);
            const code2 = tokenProvider.deriveOTC(token2.id, token2.token);
            
            assert.notEqual(code1, code2);
        });

        it('should generate different codes for same token value with different ids', function () {
            const token1 = {id: 'id-1', token: 'same-value'};
            const token2 = {id: 'id-2', token: 'same-value'};
            
            const code1 = tokenProvider.deriveOTC(token1.id, token1.token);
            const code2 = tokenProvider.deriveOTC(token2.id, token2.token);
            
            assert.notEqual(code1, code2);
        });
    });

    describe('verifyOTC', function () {
        const testToken = {
            id: 'test-token-id',
            token: 'test-token-value'
        };

        it('should verify codes generated by deriveOTC', function () {
            const code = tokenProvider.deriveOTC(testToken.id, testToken.token);
            const isValid = tokenProvider.verifyOTC(testToken.id, testToken.token, code);
            
            assert.equal(isValid, true);
        });

        it('should reject invalid codes', function () {
            const invalidCode = '123456';
            const isValid = tokenProvider.verifyOTC(testToken.id, testToken.token, invalidCode);
            
            assert.equal(isValid, false);
        });

        it('should reject codes for different tokens', function () {
            const token1 = {id: 'token-1', token: 'value-1'};
            const token2 = {id: 'token-2', token: 'value-2'};
            
            const code1 = tokenProvider.deriveOTC(token1.id, token1.token);
            const isValid = tokenProvider.verifyOTC(token2.id, token2.token, code1);
            
            assert.equal(isValid, false);
        });

        it('should handle empty string codes', function () {
            const isValid = tokenProvider.verifyOTC(testToken.id, testToken.token, '');
            
            assert.equal(isValid, false);
        });

        it('should handle non-numeric codes', function () {
            const isValid = tokenProvider.verifyOTC(testToken.id, testToken.token, 'abcdef');
            
            assert.equal(isValid, false);
        });

        it('should handle codes with wrong length', function () {
            const isValid1 = tokenProvider.verifyOTC(testToken.id, testToken.token, '12345'); // too short
            const isValid2 = tokenProvider.verifyOTC(testToken.id, testToken.token, '1234567'); // too long
            
            assert.equal(isValid1, false);
            assert.equal(isValid2, false);
        });
    });

    describe('getIdByToken', function () {
        it('should return token ID when token exists', async function () {
            const testTokenValue = 'test-token-value';
            const expectedId = 'test-token-id';
            
            // Mock successful token lookup
            mockModel.findOne.resolves({
                get: sinon.stub().returns(expectedId)
            });

            const result = await tokenProvider.getIdByToken(testTokenValue);

            assert.equal(result, expectedId);
            sinon.assert.calledOnceWithExactly(mockModel.findOne, {token: testTokenValue});
        });

        it('should return null when token does not exist', async function () {
            const testTokenValue = 'nonexistent-token';
            
            // Mock token not found
            mockModel.findOne.resolves(null);

            const result = await tokenProvider.getIdByToken(testTokenValue);

            assert.equal(result, null);
            sinon.assert.calledOnceWithExactly(mockModel.findOne, {token: testTokenValue});
        });

        it('should return null when database error occurs', async function () {
            const testTokenValue = 'test-token-value';
            
            // Mock database error
            mockModel.findOne.rejects(new Error('Database connection failed'));

            const result = await tokenProvider.getIdByToken(testTokenValue);

            assert.equal(result, null);
            sinon.assert.calledOnceWithExactly(mockModel.findOne, {token: testTokenValue});
        });

        it('should handle empty token gracefully', async function () {
            const emptyToken = '';
            
            // Mock token lookup for empty string
            mockModel.findOne.resolves(null);

            const result = await tokenProvider.getIdByToken(emptyToken);

            assert.equal(result, null);
            sinon.assert.calledOnceWithExactly(mockModel.findOne, {token: emptyToken});
        });

        it('should handle undefined token gracefully', async function () {
            const undefinedToken = undefined;
            
            // Mock token lookup for undefined
            mockModel.findOne.resolves(null);

            const result = await tokenProvider.getIdByToken(undefinedToken);

            assert.equal(result, null);
            sinon.assert.calledOnceWithExactly(mockModel.findOne, {token: undefinedToken});
        });

        it('should return null when model.get throws an error', async function () {
            const testTokenValue = 'test-token-value';
            
            // Mock model found but get() throws error
            mockModel.findOne.resolves({
                get: sinon.stub().throws(new Error('Model error'))
            });

            const result = await tokenProvider.getIdByToken(testTokenValue);

            assert.equal(result, null);
            sinon.assert.calledOnceWithExactly(mockModel.findOne, {token: testTokenValue});
        });
    });

    describe('integration tests', function () {
        it('should complete full generate/verify cycle successfully', function () {
            const tokens = [
                {id: 'token-1', token: 'value-1'},
                {id: 'token-2', token: 'value-2'},
                {id: 'token-3', token: 'value-3'}
            ];

            // Generate codes for all tokens
            const codes = tokens.map(token => ({
                token,
                code: tokenProvider.deriveOTC(token.id, token.token)
            }));

            // Verify each code works with its corresponding token
            codes.forEach(({token, code}) => {
                const isValid = tokenProvider.verifyOTC(token.id, token.token, code);
                assert.equal(isValid, true);
            });

            // Verify codes don't work with wrong tokens
            codes.forEach(({code}, index) => {
                const wrongToken = tokens[(index + 1) % tokens.length];
                const isValid = tokenProvider.verifyOTC(wrongToken.id, wrongToken.token, code);
                assert.equal(isValid, false);
            });
        });

        it('should work with different auth secrets', function () {
            // Create another provider with different secret
            const differentSecret = Buffer.from('b'.repeat(128), 'hex');
            const mockMembersConfig2 = {
                getAuthSecret: sinon.stub().returns(differentSecret)
            };

            const tokenProvider2 = new SingleUseTokenProvider({
                SingleUseTokenModel: mockModel,
                validityPeriod: 86400000,
                validityPeriodAfterUsage: 3600000,
                maxUsageCount: 3,
                secret: mockMembersConfig2.getAuthSecret()
            });

            const testToken = {id: 'test-id', token: 'test-value'};
            
            const code1 = tokenProvider.deriveOTC(testToken.id, testToken.token);
            const code2 = tokenProvider2.deriveOTC(testToken.id, testToken.token);
            
            // Different secrets should produce different codes
            assert.notEqual(code1, code2);
            
            // Each provider should only verify its own codes
            assert.equal(tokenProvider.verifyOTC(testToken.id, testToken.token, code1), true);
            assert.equal(tokenProvider.verifyOTC(testToken.id, testToken.token, code2), false);
            
            assert.equal(tokenProvider2.verifyOTC(testToken.id, testToken.token, code1), false);
            assert.equal(tokenProvider2.verifyOTC(testToken.id, testToken.token, code2), true);
        });
    });
});