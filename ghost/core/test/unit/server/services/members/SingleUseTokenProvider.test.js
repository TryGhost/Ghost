const sinon = require('sinon');
const assert = require('assert/strict');

const SingleUseTokenProvider = require('../../../../../core/server/services/members/SingleUseTokenProvider');

describe('SingleUseTokenProvider', function () {
    let tokenProvider;
    let mockMembersConfig;
    let mockModel;
    const testAuthSecret = Buffer.from('a'.repeat(128), 'hex'); // 64-byte secret

    beforeEach(function () {
        // Mock MembersConfigProvider
        mockMembersConfig = {
            getAuthSecret: sinon.stub().returns(testAuthSecret)
        };

        // Mock SingleUseTokenModel (minimal - we're not testing existing functionality)
        mockModel = {
            add: sinon.stub(),
            findOne: sinon.stub(),
            transaction: sinon.stub()
        };

        tokenProvider = new SingleUseTokenProvider({
            SingleUseTokenModel: mockModel,
            validityPeriod: 86400000, // 24 hours
            validityPeriodAfterUsage: 3600000, // 1 hour
            maxUsageCount: 3,
            membersConfig: mockMembersConfig
        });
    });

    afterEach(function () {
        sinon.restore();
    });

    describe('deriveCode', function () {
        const testToken = {
            id: 'test-token-id',
            token: 'test-token-value'
        };

        it('should generate a 6-digit code', function () {
            const code = tokenProvider.deriveCode(testToken);
            
            assert.equal(typeof code, 'string');
            assert.match(code, /^\d{6}$/);
        });

        it('should generate consistent codes for the same token', function () {
            const code1 = tokenProvider.deriveCode(testToken);
            const code2 = tokenProvider.deriveCode(testToken);
            
            assert.equal(code1, code2);
        });

        it('should generate different codes for different tokens', function () {
            const token1 = {id: 'token-1', token: 'value-1'};
            const token2 = {id: 'token-2', token: 'value-2'};
            
            const code1 = tokenProvider.deriveCode(token1);
            const code2 = tokenProvider.deriveCode(token2);
            
            assert.notEqual(code1, code2);
        });

        it('should generate different codes for same id with different token values', function () {
            const token1 = {id: 'same-id', token: 'value-1'};
            const token2 = {id: 'same-id', token: 'value-2'};
            
            const code1 = tokenProvider.deriveCode(token1);
            const code2 = tokenProvider.deriveCode(token2);
            
            assert.notEqual(code1, code2);
        });

        it('should generate different codes for same token value with different ids', function () {
            const token1 = {id: 'id-1', token: 'same-value'};
            const token2 = {id: 'id-2', token: 'same-value'};
            
            const code1 = tokenProvider.deriveCode(token1);
            const code2 = tokenProvider.deriveCode(token2);
            
            assert.notEqual(code1, code2);
        });
    });

    describe('verifyCode', function () {
        const testToken = {
            id: 'test-token-id',
            token: 'test-token-value'
        };

        it('should verify codes generated by deriveCode', function () {
            const code = tokenProvider.deriveCode(testToken);
            const isValid = tokenProvider.verifyCode(testToken, code);
            
            assert.equal(isValid, true);
        });

        it('should reject invalid codes', function () {
            const invalidCode = '123456';
            const isValid = tokenProvider.verifyCode(testToken, invalidCode);
            
            assert.equal(isValid, false);
        });

        it('should reject codes for different tokens', function () {
            const token1 = {id: 'token-1', token: 'value-1'};
            const token2 = {id: 'token-2', token: 'value-2'};
            
            const code1 = tokenProvider.deriveCode(token1);
            const isValid = tokenProvider.verifyCode(token2, code1);
            
            assert.equal(isValid, false);
        });

        it('should handle empty string codes', function () {
            const isValid = tokenProvider.verifyCode(testToken, '');
            
            assert.equal(isValid, false);
        });

        it('should handle non-numeric codes', function () {
            const isValid = tokenProvider.verifyCode(testToken, 'abcdef');
            
            assert.equal(isValid, false);
        });

        it('should handle codes with wrong length', function () {
            const isValid1 = tokenProvider.verifyCode(testToken, '12345'); // too short
            const isValid2 = tokenProvider.verifyCode(testToken, '1234567'); // too long
            
            assert.equal(isValid1, false);
            assert.equal(isValid2, false);
        });
    });

    describe('integration tests', function () {
        it('should complete full generate/verify cycle successfully', function () {
            const tokens = [
                {id: 'token-1', token: 'value-1'},
                {id: 'token-2', token: 'value-2'},
                {id: 'token-3', token: 'value-3'}
            ];

            // Generate codes for all tokens
            const codes = tokens.map(token => ({
                token,
                code: tokenProvider.deriveCode(token)
            }));

            // Verify each code works with its corresponding token
            codes.forEach(({token, code}) => {
                const isValid = tokenProvider.verifyCode(token, code);
                assert.equal(isValid, true);
            });

            // Verify codes don't work with wrong tokens
            codes.forEach(({code}, index) => {
                const wrongToken = tokens[(index + 1) % tokens.length];
                const isValid = tokenProvider.verifyCode(wrongToken, code);
                assert.equal(isValid, false);
            });
        });

        it('should work with different auth secrets', function () {
            // Create another provider with different secret
            const differentSecret = Buffer.from('b'.repeat(128), 'hex');
            const mockMembersConfig2 = {
                getAuthSecret: sinon.stub().returns(differentSecret)
            };

            const tokenProvider2 = new SingleUseTokenProvider({
                SingleUseTokenModel: mockModel,
                validityPeriod: 86400000,
                validityPeriodAfterUsage: 3600000,
                maxUsageCount: 3,
                membersConfig: mockMembersConfig2
            });

            const testToken = {id: 'test-id', token: 'test-value'};
            
            const code1 = tokenProvider.deriveCode(testToken);
            const code2 = tokenProvider2.deriveCode(testToken);
            
            // Different secrets should produce different codes
            assert.notEqual(code1, code2);
            
            // Each provider should only verify its own codes
            assert.equal(tokenProvider.verifyCode(testToken, code1), true);
            assert.equal(tokenProvider.verifyCode(testToken, code2), false);
            
            assert.equal(tokenProvider2.verifyCode(testToken, code1), false);
            assert.equal(tokenProvider2.verifyCode(testToken, code2), true);
        });
    });
});